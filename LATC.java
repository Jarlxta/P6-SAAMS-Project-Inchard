
// Generated by Together


import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Observable;
import java.util.Observer;

/**
 * An interface to SAAMS:
 * Local Air Traffic Controller Screen:
 * Inputs events from LATC (a person), and displays aircraft information.
 * This class is a controller for the AircraftManagementDatabase: sending it messages to change the aircraft status information.
 * This class also registers as an observer of the AircraftManagementDatabase, and is notified whenever any change occurs in that <<model>> element.
 * See written documentation.
 * @stereotype boundary/view/controller
 * @url element://model:project::SAAMS/design:view:::id15rnfcko4qme4cko4swib
 * @url element://model:project::SAAMS/design:view:::id2fh3ncko4qme4cko4swe5
 * @url element://model:project::SAAMS/design:node:::id15rnfcko4qme4cko4swib.node107
 * @url element://model:project::SAAMS/design:view:::idwwyucko4qme4cko4sgxi
 */
public class LATC extends JFrame implements Observer, ActionListener, ListSelectionListener {

  private final String LATC_NAME = "Local Air Traffic Controls";
  private final JLabel controls = new JLabel("Controls");
  private final JLabel inbounds = new JLabel("Inbound");
  private final JButton allowApproachClearance = new JButton("Allow Approach Clearance");
  private final JButton confirmPlaneLanding = new JButton("Confirm Plane Has Landed");
  private final JLabel outBound = new JLabel("Outbound");
  private final JButton allocateDepartureSlot = new JButton("Allocate Departure Slot");
  private final JButton permitTakeOff = new JButton("Permit Takeoff");
  private final JLabel planeDetails = new JLabel("Plane Details");
  private DefaultListModel<String> selectedPlane = new DefaultListModel<>();
  private final JList planeDetailsTF = new JList(selectedPlane);
  private final JLabel planesJL = new JLabel("Planes");
  private DefaultListModel<String> planesIncoming = new DefaultListModel<>();
  private final JList planesTF = new JList(planesIncoming);
  private int currentPlaneIndex;

  private List<String> statuses;


/**
  *  The Local Air Traffic Controller Screen interface has access to the AircraftManagementDatabase.
  * @supplierCardinality 1
  * @clientCardinality 1
  * @label accesses/observes
  * @directed*/

private AircraftManagementDatabase aMDatabase;


  public LATC(AircraftManagementDatabase aircraftManagementDatabase) {
    this.aMDatabase = aircraftManagementDatabase;
    this.currentPlaneIndex = -1;
    // if I want to mess with some JFrame components like color
    Container window = getContentPane();
    //creating the buttons, labels and the text fields for this view
    initiateGUI(window);
    createLabels();
    createButtons();
    createTextFields();
    //adding functionality
    this.aMDatabase.addObserver(this); //adds this view/controller as an observer to the changes made in the AircraftManagementDatabase
    setVisible(true);

    statuses = new ArrayList<String>();
    statuses.add("FREE");
    statuses.add("IN TRANSIT");
    statuses.add("WANTING_TO_LAND");
    statuses.add("GROUND_CLEARANCE_GRANTED");
    statuses.add("LANDING");
    statuses.add("LANDED");
    statuses.add("TAXXING");
    statuses.add("UNLOADING");
    statuses.add("READY_CLEAN_AND_MAINT");
    statuses.add("FAULTY_AWAITING_CLEAN");
    statuses.add("CLEAN_AWAIT_MAINT");
    statuses.add("OK_AWAIT_CLEAN");
    statuses.add("AWAIT_REPAIR");
    statuses.add("READY_REFUEL");
    statuses.add("READY_PASSENGERS");
    statuses.add("READY_DEPART");
    statuses.add("AWAITING_TAXI");
    statuses.add("AWAITING_TAKEOFF");
    statuses.add("DEPARTING_THROUGH_LOCAL_AIRSPACE");
}

  public void createLabels() {
    planesJL.setBounds(5, 20, 150, 20);
    add(planesJL);
    controls.setBounds(330, 40, 100, 20);
    add(controls);
    inbounds.setBounds(330, 65, 100, 20);
    add(inbounds);
    outBound.setBounds(330, 175, 100, 20);
    add(outBound);
    planeDetails.setBounds(330, 285, 100, 20);
    add(planeDetails);
  }

  public void createButtons() {
    allowApproachClearance.setBounds(270, 90, 200, 30);
    allowApproachClearance.addActionListener(this);
    add(allowApproachClearance);
    confirmPlaneLanding.setBounds(270, 125, 200, 30);
    confirmPlaneLanding.addActionListener(this);
    add(confirmPlaneLanding);
    permitTakeOff.setBounds(270, 235, 200, 30);
    permitTakeOff.addActionListener(this);
    add(permitTakeOff);
    allocateDepartureSlot.setBounds(270, 200, 200, 30);
    allocateDepartureSlot.addActionListener(this);
    add(allocateDepartureSlot);
  }

  public void createTextFields() {
    planesTF.setVisible(true);
    planesTF.setBounds(5, 45, 260, 410);
    planesTF.addListSelectionListener(this);
    add(planesTF);
    planeDetailsTF.setBounds(270, 305, 200, 150);
    add(planeDetailsTF);
  }


  public void initiateGUI(Container win) {
    setLayout(null);
    setTitle(LATC_NAME);
    setLocation(40, 40);
    setSize(500, 500);
    setDefaultCloseOperation(EXIT_ON_CLOSE);
  }


//  public String flightsLandingOrTransit() {
//    return aircraftManagementDatabase.getStatus()
//  }
  @Override
  public void actionPerformed(ActionEvent e) {
    if (e.getSource() == allowApproachClearance){

      if (currentPlaneIndex == -1){
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: You need to select an aircraft.");
      }
      else if (aMDatabase.getStatus(currentPlaneIndex) != statuses.indexOf("GROUND_CLEARANCE_GRANTED")){
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: The aircraft's status is not currently valid for this operation.");
      }
      else {
        aMDatabase.setStatus(currentPlaneIndex, statuses.indexOf("LANDING"));
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: Granted approach clearance to Aircraft " + aMDatabase.getFlightCode(currentPlaneIndex));
      }
    }

    if (e.getSource() == confirmPlaneLanding){
      if (currentPlaneIndex == -1){
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: You need to select an aircraft.");
      }
      else if (aMDatabase.getStatus(currentPlaneIndex) != statuses.indexOf("LANDING")){
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: The aircraft's status is not currently valid for this operation.");
      }
      else {
        aMDatabase.setStatus(currentPlaneIndex, statuses.indexOf("LANDED"));
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: Aircraft " + aMDatabase.getFlightCode(currentPlaneIndex) + " landing confirmed.");
      }
    }

    if (e.getSource() == allocateDepartureSlot){
      if (currentPlaneIndex == -1){
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: You need to select an aircraft.");
      }
      else if (aMDatabase.getStatus(currentPlaneIndex) != statuses.indexOf("READY_DEPART")){
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: The aircraft's status is not currently valid for this operation.");
      }
      else {
        aMDatabase.setStatus(currentPlaneIndex, statuses.indexOf("AWAITING_TAXI"));
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: Aircraft " + aMDatabase.getFlightCode(currentPlaneIndex) + " assigned airslot, awaiting taxi.");
      }
    }

    if (e.getSource() == permitTakeOff){
      if (currentPlaneIndex == -1){
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: You need to select an aircraft.");
      }
      else if (aMDatabase.getStatus(currentPlaneIndex) != statuses.indexOf("AWAITING_TAKEOFF")){
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: The aircraft's status is not currently valid for this operation.");
      }
      else {
        aMDatabase.setStatus(currentPlaneIndex, statuses.indexOf("DEPARTING_THROUGH_LOCAL_AIRSPACE"));
        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(), "LATC: Aircraft " + aMDatabase.getFlightCode(currentPlaneIndex) + " granted clearance for takeoff, and they are now departing through local airspace.");
      }
    }
  }

  @Override
  public void update(Observable o, Object arg) {
    List<Integer> freeMCodes = aMDatabase.getWithStatus(0);
    int maxMRs = 10;
    planesIncoming.clear();

    for (int i = 0; i < maxMRs; i ++){
      if (!freeMCodes.contains(i)){
        planesIncoming.addElement(aMDatabase.getFlightCode(i) + " - " + statuses.get(aMDatabase.getStatus(i)));
      }
    }

  }

  @Override
  public void valueChanged(ListSelectionEvent e) {
    if (e.getValueIsAdjusting()) {
      selectedPlane.clear();
      currentPlaneIndex = planesTF.getSelectedIndex();
      selectedPlane.addElement(planesIncoming.get(currentPlaneIndex));
      selectedPlane.addElement("DEPARTED FROM: " + aMDatabase.getItinerary(currentPlaneIndex).getFrom());
      selectedPlane.addElement("CURRENT DESTINATION: " + aMDatabase.getItinerary(currentPlaneIndex).getTo());
      selectedPlane.addElement("FINAL DESTINATION: " + aMDatabase.getItinerary(currentPlaneIndex).getNext());
    }
  }
}
